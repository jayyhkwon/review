



## 한 권으로 그리는 컴퓨터 과학 로드맵

<img src="https://image.aladin.co.kr/product/14104/21/cover500/8966262198_1.jpg">





### Chapter03 - 문제 해결 전략



> **목차**
>
> - 3.1 반복 전략
> - 3.2 재귀를 이용해 반복하기
> - 3.3 무식하게 풀기 : 모든 후보 검사하기
> - 3.4 역추적 : 불필요한 탐색 그만두기
> - 3.5 발견법 : 정답에 가까운 답 구하기
>   - 탐욕법
> - 3.6 분할정복 : 더 작은 문제로 나누어 풀기
> - 3.7 동적 계획법 : 계산 결과를 기억하며 풀기
> - 3.8 분기한정법 : 답의 범위를 좁히며 풀기(내용 추가 예정)

<br>

<br>



> **반복 전략**

- 루프(for,while 문) 속에서 조건이 충족될 때 까지 절차를 반복하는 것

- 대표적인 예로 2개의 리스트를 1개로 합치는 병합 알고리즘이 있다

<br>

<br>



> **재귀를 이용해 반복하기**

- 재귀란 어떤 함수가 자기 자신이나 자신의 복제본에 작업을 전파하는 것

- 대표적인 예로 피보나치 수, 회문(palindrome)을 재귀로 구현 할 수 있다

- 재귀 알고리즘에는 base case가 존재하고 입력 데이터가 더 이상 작아질 수 없는 경우로 <br>

  재귀 알고리즘이 끝나는 지점을 의미한다.

- **재귀 vs 반복**
  - 가독성면에서 재귀가 장점이 있을 수 있으나, 메모리와 추가 연산(스택을 만들고 넘나드는 비용)이 필요하여 비용이 더 많이 들 수 있다.

<br>

<br>

> **무식하게 풀기 : 모든 후보 검사하기**

- 브루트포스 또는 완전 탐색이라고도 부르며, 답이 될 수 있는 후보를 전부 조사하여 문제를 해결한다

<br>

<br>

> **최적 거래 문제**
>
> 일정 기간  동안의 금 가격이 주어져 있다. 이 기간 중 며칠에 금을 사고 며칠에 금을 팔았을 때 이윤을 최대화 할 수 있는지 알고 싶다. 금을 사고 파는 최적의 두 날짜를 구하라.

<br>

<br>

> **브루트 포스 방식으로 푼다면?**

- 가능한 모든 날짜 쌍을 구해 답을 찾는다.
- 시간복잡도는 O(n^2) 

<br>

<br>

> **배낭 문제**
>
> 한 상인이 상품을 배낭에 골라담아 시장에 내다 파려고 한다. 각 상품의 무게와 가치가 주어져 있으며, 배낭에는 상품을 일정한 무게까지만 담을 수 있다. 배낭에 상품을 담아갈 기회는 단 한 번이다. 배낭에 담은 상품의 가치를 가장 높게 하려면 어떤 상품을 골라야 하는가?

<br>

<br>

> **브루트 포스 방식으로 푼다면?**

- 가능한 모든 조합(멱집합)을 구한다

- 시간복잡도는 O(2^n)

- **상품 조합을 모두 검사해야 할까? 상품 조합중에는 가벼운 상품 한 두개만 담거나 배낭을 반 이상 비워놓는 경우도 있을 텐데 이러한 가능성 없는 후보들은 제외하여 좀 더 효율적으로 탐색하는 전략은 없을까?**

<br>

<br>

> **역추적 : 불필요한 탐색 그만두기**

- 백트래킹이라고도 불리며 올바르게 탐색을 이어나갈 수 있을 때만 탐색을 이어나가는 방식

<br>

<br>

> **N-Queen 문제**
>
> 크기가 N * N 인 체스판 위에 퀸 N 개를 서로 공격할 수 없게 놓는 문제이다. 
> N이 주어졌을 때, 퀸을 놓는 방법의 수를 구하는 프로그램을 작성하시오.



<img src="https://t1.daumcdn.net/cfile/tistory/99B8D13F5A927B1132">



<br>

<br>

> 브루트 포스 방식으로 푼다면?

- 퀸을 둘 수 없는 곳에 둔  것도 끝까지 조사하기 때문에 시간이 낭비된다

<br>

<br>

> 백트래킹 방식으로 푼다면?

- 퀸을 둘 수 있는 자리는 앞서 둔 퀸에 의해서 제한된다.

- N번째 퀸을 두기 전에 더 이상 퀸을 둘 자리가 없다면, 가장 최근에 둔 수가 틀린 것이므로<br>

  그 수를 물리고 다른 위치에 퀸을 두는 탐색을 계속해 나간다.

- **브루트 포스방식보다 검색속도가 빠르다.**

<br>

<br>

> **발견법 : 정답에 가까운 답 구하기**

- 체스의 경우 사용되는 말은 여섯 종, 32개이며 이 말들을 둘 수 있는 칸은 64개다.<br>

  첫 수를 둘 수 있는 경우의 수는 4백 가지, 두 번째 수 까지 두는 경우의 수는 7만2천 가지, 세 번째 수까지 두는 방법은 9백만 가지, 네 번째 수까지 두는 경우의 수는 2,880억 가지에 달하게 된다. 이러한 상황에서 자기 차례에 가장 좋은 수가 무엇인지 알아내는 것은 불가능하다. **그저 직관에 의존해 충분히 좋은 수를 찾아내야 한다.**<br>

  **이러한 전략을 발견법이라 부르며, 최적과 최선을 찾으리라는 보장은 없지만 그에 가까운 답을 찾을 수 있다. <br>**

  **브루트 포스나 백트래킹 전략이 시간이 너무 많이 걸릴때 발견법을 사용하면 유용할 수 있다.**

<br>

<br>

> **탐욕법**

- 발견법 가운데 가장 흔히 사용되는 것이 바로 탐욕법이다.
- **이전의 선택으로 절대 돌아가지 않는 방식으로, 이전의 선택으로 계쇡 되돌아가는 백트래킹 전략과 정반대 전략이다.**

<br>

<br>

> 배낭 문제 (탐욕 버전)
>
> 탐욕스러운 절도범이 당신의 집에 숨어들어 상품을 훔쳐가려 한다. 절도범은 훔친 물건을 당신의 배낭에 담아갈 예정이다. 어떤 물건을 훔쳐가려 할까? 집에 머물러 있는 시간이 짧을 수록 잡힐 확률도 줄어들 것이다.

- 최적해(가장 완벽한 답)을 구하려 한다면 앞서 풀어보았던 배낭문제와 완전히 동일한 문제이다.
- 하지만 주인이 언제 돌아올지 모르는 상황에서 모든 조합을 하나씩 검사해 본다거나 이미 담았던 물건을 다시 꺼내며 비교할 시간은 없다.
- 절도범은 더 이상 물건을 담을 수 없을 때까지 가장 가치가 높은 물건부터 순서대로 배낭에 물건을 담을 것이다.

- 이렇게 구한 상품 조합은 반드시 최고가의 조합이라는 보장은 없다.(가치/무게 까지 다 따져야 최고가 조합을 구할 수 있다)

<br>

<br>

> **분할 정복 : 더 작은 문제로 나누어 풀기**

- **최적 부분 구조로 구성된 문제를 해결하기에 적합하다.<br>**

  최적 부분 구조란 비슷한 형태의 더 작은 부분 문제로 나눌 수 있는 문제로, 이렇게 나뉜 부분 문제 역시 같은 방식으로 계속 나눌 수 있으며 계속 나누다보면 결국 쉽게 풀 수 있는 간단한 문제가 될 것이다. 이 간단한 문제들의 답을 각각 구한 뒤 서로 결합하면 문제의 답을 구할 수 있다.

- 대표적인 예로 합병정렬이 있다.

```markdown
단계별 연산 횟수 측정
1. 리스트를 절반으로 나누는 작업
	- 리스트 항목의 갯수에 상관없이 O(1)

2. 병합(merge) : O(n)

3. 분할(divide)
	- 분할 단계 1. merge_sort 함수가 n개 항목을 가진 리스트를 대상으로 호출된다. -> O(n)
	- 분할 단계 2. merge_sort 함수가 n/2개 항목을 가진 리스트를 대상으로 2번 호출된다. -> 2 * O(n/2) = O(n)
	- 분할 단계 3. merge_sort 함수가 n/4개 항목을 가진 리스트를 대상으로 4번 호출된다. -> 4 * O(n/4) = O(n) 
	- 분할 단계 x. merge_sort 함수가 n/2^x개 항목을 가진 리스트를 대상으로 2번 호출된다. -> 2^x * O(n/2^x) = O(n) 

	- base case(1개의 항목을 가진 리스트)는 n/2^x = 1이므로 <br>
    x = logn
  - 따라서 병합정렬의 시간복잡도는 logn * O(n) = O(nlogn)
  
```

<br>

<br>

>  **동적 계획법 : 계산 결과를 기억하며 풀기**

- 문제를 풀 때, 동일한 연산이 여러 차례 수행되는 경우가  있다. **동적 계획법을 활용하면 반복되는 부분 문제를 식별하여 이들을 한 번씩만 연산할 수 있다. 이를 위해 memoize(저장) 기법을 활용한다.**

```markdown


1. f(5)를 구하기 위해서 f(4)와 f(3)을 구함
 2. f(5)에서 호출된 f(4)를 구하기 위해서 f(3)와 f(2)를 호출함
 3. f(4)에서 호출된 f(3)을 구하기 위해서 f(2)와 f(1)을 호출함
 4. f(5)에서 호출된 f(3)을 구하기 위해서 f(2)와 f(1)을 호출함 (또 호출함)
=> 총 9번 호출됨
4번 과정에서 중복호출된 f(2),f(1)의 결과값이 저장되어 있다면 중복연산 없이 값을 바로 구할 수 있다.
```



```java

int memo[100]; //메모이제이션 공간. 전역 변수이므로 0으로 초기화
int fibonacci(int n)
{
  if (n<=1) //0번째, 1번째 피보나치 수
    return n;
  if (memo[n]!=0) //메모가 있는지 확인(0으로 초기화되었으므로 0이 아니라면 메모가 쓰인 것임)
    return memo[n]; //메모 리턴
  memo[n]=fibonacci(n-1) + fibonacci(n-2); //작은 문제로 분할
  return memo[n];
}
```



> **분기한정법 : 답의 범위를 좁히며 풀기**

- 최단 경로 탐색, 이윤 최대화 와 같은 문제를 최적화 문제라 한다.

- 분기한정법은 최적화 문제에서 구하려는 답이 '선택의 연속' 일 때, 자주 활용되는 전략이다.<br>

  나쁜 선택지를 빠르게 제거하여 시간을 절약한다. 나쁜 선택지를 알아내기 위해서는 상한과 하한이라는 개념이 필요하다.



> **상한과 하한**

- 어떤 값의 범위를 지정하는 것을 한정이라고 한다.

- 상한은 값의 최대치를 한정하는 것이고, 하한은 값의 최소치를 한정하는 것이다.





ref. <a href="https://thd0011.tistory.com/19">N-Queen</a>

ref. <a href="[https://jayyhkwon.github.io/algorithm/2019/12/08/Algorithm-mergeSort-%EC%8B%9C%EA%B0%84%EB%B3%B5%EC%9E%A1%EB%8F%84/](https://jayyhkwon.github.io/algorithm/2019/12/08/Algorithm-mergeSort-시간복잡도/)"> 합병정렬 시간복잡도</a>